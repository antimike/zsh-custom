#!/bin/zsh -f
# Queries the Github API to retrieve repository metadata
# Returns raw JSON

# IO stuff
local __FILE__=${(%):-%x}
local -A levels=(
    [info]="${reset_color}"
    [debug]="${fg_bold[yellow]}${bg[blue]}"
    [success]="${fg_bold[green]}"
    [warn]="${fg_bold[yellow]}"
    [error]="${fg_bold[red]}"
)

__print() {
    local color=$colors[$1]
    local -i vb=$2
    shift 2
    (( vb >= verbosity )) && print -- "${color}$@${reset_color}"
}
__debug() {
    __print debug 2 "DEBUG:${__NAME__}@${LINENO}: $@"
}

__inform() {
    __print info 1 $@
}

__warn() {
    __print warn 1 "WARNING: $@"
}

__error() {
    __print error 0 "ERROR: $@"
}

__fail() {
    __error ${@[2,-1]}
    exit $1
} >&2

# Personal `pass` extension
# Ensures that GH credentials are available as env variables
eval $(pass env -q)

local -a curl_opts=(
    --silent
    -H 'Accept: application/vnd.github.preview'
    -w "%{stderr}%{http_code}"
)
if [[ -n "$GITHUB_USER" && -n "$GITHUB_TOKEN" ]]; then
    curl_opts+=( -u "${GITHUB_USER}:${GH_TOKEN}" )
else
    print "Github token not found; using unauthenticated Github API" >&2
fi

local -A URLS=(
    [base]="https://github.com"
    [api]="https://api.github.com/repos"
    [raw]="https://raw.githubusercontent.com"
)

local -A fields=(
    [stars]="stargazers_count"
)

local -a comments=() tags=() srcs=() yml_srcs=() attrs=()
local cmd=
local -i verbosity=1
local -A errors=( )
trap 'print -aC 2 -- ${(kv)errors} >&2' EXIT

__parse_args() {
    eval set -- $(getopt -o "c:t:a:yjY:J:F:hvVq" -l "comment:,tag:,attr:,yaml,json,from-json:,from-file:,help,quiet" -- $@)
    while [[ $# -gt 0 ]]; do
        case $1 in
            -c|--comment) comments+=( "$2" ); shift ;;
            -t|--tag) tags+=( "$2" ); shift ;;
            -a|--attr) attrs+=( "$2" ); shift ;;
            -y|--yaml) yq_opts+=( -Y ) ;;
            -j|--json) yq_opts=( ${yq_opts#-Y} ) ;;
            -J|--from-json) yml_src+=( "$2" ); shift ;;
            -F|--from-file) src+=( "$2" ); shift ;;
            -h|--help) __help; exit 0 ;;
            -v) let verbosity+=1 ;;
            -V) let verbosity-=1 ;;
            -q|--quiet) let verbosity=0 ;;
            --) shift; break ;;
            *) __fail "Unknown option '$1'" ;;
        esac
        shift
    done
}

__get_cmd() {
    if [[ -z ${cmd:=${:-(grep -m1 -so "^_${1}.*()" $__FILE__)}%()} ]]
    then
        __fail 1 "Subcommand '$1' not implemented"
    fi
    shift
    fields[timestamps]="{(now|todate):\"${cmd#_} $@\"}"
    $cmd $@
}

__help() {
    # Prints "docstring" of calling function
    caller=${funcstack[-2]:-$funcstack[-1]}
    sed -n "/^${caller}()/,/^[^#]/p" $__FILE__ |
        sed "1c\\${caller#_}" | sed '$d' | sed 's/^#//'
}

__process_json() {
    jq '
        to_entries |
            reduce .[] as $kv ([{},{}]; if ($kv|key|test("url")) then [.[0], .[1]+$kv] else [.[0]+$kv, .[1]] end) |
            map(from_entries) | .[0]+{"urls":.[1]}
        '
}

_metadata() {
    local stem url
    local -i http_ret

    while [[ $# -gt 0 ]]; do
        stem="${1#${URLS[base]}/}"
        url="${URLS[api]}/${stem}"
        http_ret="$( {curl $curl_opts $url; } 2>&1 1>&3 3>&- )" 3>&1
        if [[ $http_ret -lt 200 || $http_ret -gt 299 ]]; then
            errors[$1]=$http_ret
        fi
        shift
    done
}



main() {
    return $#errors
}

main $@
