{"keys": "#!/bin/zsh -f\n\nwhile read map\ndo\n        bindkey -M $map | sed \"s/^/${map}:/\"\ndone < <(bindkey -l) | column -t -s: | fzf", "readme2man": "#!/bin/zsh -f\n# Symlinks README.{md,rst,adoc,...} files to local man1r directory and converts it to roff markup, placing the results in man1r as well\n\n# Ensures options are local to this function and sets MULTIOS option\nemulate -L zsh\nsetopt MULTIOS\n\nlocal logfile=~/.cache/readme2man.log\ntouch $logfile && print -l \"[`date -u` :: pwd: `pwd`]\" $* >>$logfile\nlocal cmd=$1 readme=$2\n\n# Check that README file exists and cmd is a valid command\nif [[ ! -r $readme ]]; then\n        print \"File '$readme' was not found or is not readable\" >&2 >$logfile\n        return 1\nelif ! command -v $cmd >/dev/null; then\n        print \"'$cmd' is not a valid command\" >&2 >$logfile\n        return 2\nfi\n\nlocal target=~/.local/share/man/man1r/${cmd}.${readme:t}\nlocal dest=~/.local/share/man/man1r/${cmd}.1r\nlocal convert_cmd\n\nln -s ${readme:P} $target || return 3\n\ncase ${readme:e} in\n        md|markdown|mkdn) convert_cmd=md2man-roff ;;\n        rst) convert_cmd=\"rst2man -t -g --source-url=${readme} --warnings=${logfile}\" ;;\n        adoc) convert_cmd=\"asciidoctor -b manpage -d manpage -\" ;;\nesac\n\n$convert_cmd <$readme >$dest || print \"Conversion failed\" >&2 >$logfile", "icons": "# Get overall terminal dimensions\n< <(</dev/tty stty size) \\\n        read TERMINAL_LINES TERMINAL_COLUMNS\n\n# Ensure graphics are cleared on completion, including interrupts\ntrap 'kitty +kitten icat --clear' EXIT SIGINT\n\n# Get cursor position using ANSI witchcraft\necho -ne '\\033[6n' >/dev/tty && IFS='[;' </dev/tty read -t 1 -s -d 'R' _ CURSOR_Y CURSOR_X _\n\nfind /usr/share/icons -type f | fzf --preview=\"\n        BOT=\\$((CURSOR_Y + FZF_PREVIEW_LINES > TERMINAL_LINES ? TERMINAL_LINES : CURSOR_Y + FZF_PREVIEW_LINES))\n        TOP=\\$((BOT - FZF_PREVIEW_LINES + 2))\n        kitty +kitten icat --transfer-mode file --clear &&\n        kitty +kitten icat \\\n                --place=\\${FZF_PREVIEW_COLUMNS}x\\${FZF_PREVIEW_LINES}@\\$((TERMINAL_COLUMNS - FZF_PREVIEW_COLUMNS - 4))x\\${TOP} \\\n                --silent --transfer-mode file {}\n        \"", "fonts": "# From fzf-ueberzug\n# local -r -x IMAGE_CACHE_PATH=$(mktemp --suffix=\"fonts-preview-`date +%s`-$$.png\")\nlocal -r -x IMAGE_CACHE_PATH=~/img_preview.png\nlocal -r -x DEFAULT_PREVIEW_POSITION=\"right\"\nlocal -x CURSOR_X CURSOR_Y\n\n# From font-preview\nlocal -x SEARCH_PROMPT=\"\u276f \"\nlocal -x SIZE=532x365\nlocal -x POSITION=\"+0+0\"\nlocal -x FONT_SIZE=38\nlocal -x BG_COLOR=\"#ffffff\"\nlocal -x FG_COLOR=\"#000000\"\nlocal -x PREVIEW_TEXT=\"ABCDEFGHIJKLM\\nNOPQRSTUVWXYZ\\nabcdefghijklm\\nnopqrstuvwxyz\\n1234567890\\n!@$\\%(){}[]\"\n\n# Ensure graphics are cleared on completion, including interrupts\ntrap \"rm -f $IMAGE_CACHE_PATH && kitty +kitten icat --clear\" EXIT SIGINT\n\n# Get cursor position using ANSI witchcraft\necho -ne '\\033[6n' >/dev/tty && IFS='[;' </dev/tty read -t 1 -s -d 'R' _ CURSOR_Y CURSOR_X _\n\n# List fonts with imagemagick and feed the list to FZF\nconvert -list font | awk -F: '/^[ ]*Font: /{print substr($NF,2)}' |\n        fzf --prompt=$SEARCH_PROMPT --preview=\"\n                BOT=\\$((CURSOR_Y + FZF_PREVIEW_LINES > LINES ? LINES : CURSOR_Y + FZF_PREVIEW_LINES))\n                TOP=\\$((BOT - FZF_PREVIEW_LINES + 2))\n                kitty +kitten icat --transfer-mode file --clear &&\n                convert -size $SIZE \\\n                        xc:none \\\n                        -background transparent \\\n                        -gravity center \\\n                        -pointsize $FONT_SIZE \\\n                        -font {} \\\n                        -fill $BG_COLOR \\\n                        -annotate +0+0 $PREVIEW_TEXT \\\n                        -flatten $IMAGE_CACHE_PATH &&\n                kitty +kitten icat \\\n                        --place=\\${FZF_PREVIEW_COLUMNS}x\\${FZF_PREVIEW_LINES}@\\$((COLUMNS - FZF_PREVIEW_COLUMNS - 4))x\\${TOP} \\\n                        --silent --transfer-mode file $IMAGE_CACHE_PATH\"", "readme": "# @date March 2022\n# @author Michael Haynes\n# @name readme\n# @summary Fetch a README from a remote repository\n# @synopsis\n# @description `@name` uses `curl` to download the README document from a remote git repository, writing the result to a user-specified destination (default ~/.local/share/man/man1r).  Optionally, the downloaded file will then be converted to `roff` format by an appropriate tool and added to a relevant mansection (default is `1r`, i.e. \"command READMEs\").\n# @options\n\nzmodload zsh/zutil\n\nlocal -r MANDIR=~/.local/share/man/man1r\n\nlocal -A opts=(\n        [-N]=README                     # @zshopt Base filename.  Defaults to README.\n        [-e]=md                         # @zshopt Extension (defaults to md).  Can be provided with or without a leading dot.\n        [-b]=master                     # @zshopt Branch\n        [-f]=                           # @zshopt Filename. If provided, overrides {basename}.{ext} construction of filename.\n        [-u]=                           # @zshopt Repository URL.  If provided, overrides all other attempts at constructing URL.\n        [-d]=~/.local/share/man/man1r   # @zshopt Destination directory for downloaded README.  Default is ~/.local/share/man/man1r/${cmd_name}.${filename}.\n)\nlocal -a flags=(\n        -v                              # @zshopt Print verbose output to stderr.\n        -h                              # @zshopt Display helptext and exit.\n)\n\nzparseopts -D -E -K -A opts -- ${^${(k)opts#-}}: ${^flags#-}=flags\nlocal name=$1 filename=${opts[-f]:-${opts[-N]}.${opts[-e]}}\nlocal url=${opts[-u]:-${filename}} branch=${opts[-b]}\nlocal outdir=${opts[-d]} dest=${outdir}/${name}.${filename}\n\nif [[ -z $name ]]; then\n        print \"Error: You must provide a name for the command you wish to document or peruse\" >&2\n        return 1\nelif ! command -v $name >/dev/null 2>&1; then\n        print \"Error: Command '$name' not found\" >&2\n        return 2\nfi\n\nif [[ -z $url ]]; then\n        local -a docs=(${(f)\"$(find $MANDIR -type f -name \"*${name}*\" -printf '%f\\n')\"})\n        url=$( print -l $docs | fzf --prompt=\"Choose README file to display\" --preview=\"pistol ${MANDIR}/{}\") || return 3\nfi\nif [[ -z $url ]]; then          # Nothing selected\n        print \"No document selected\" >&2\n        return 4\nelif [[ -e $url ]]; then        # README is already local\n        pistol $url\nelse                            # Remote URL.  Fetch and process\n        case $url in\n                *github*)\n                        case $url in\n                                *raw*) ;;       # Do nothnig---assume user knows what's up\n                                *)\n                                        # Deconstruct URL and reassemble to make sure it's in the right format\n                                        url=${${${${url%blob*}%/${branch}*}%/${filename}*}#*github.com/}\n                                        url=https://github.com/${url}/raw/${branch}/${filename}\n                                        ;;\n                        esac\n                        ;;\n                *) ;;   # TODO: Implement more site-specific logic\n        esac\n        curl -L ${url} -o ${dest} &&\n                pistol ${dest}\nfi"}